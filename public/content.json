{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"分析","slug":"Vue中computed分析","date":"2022-07-15T07:36:39.409Z","updated":"2022-07-15T07:38:08.000Z","comments":true,"path":"2022/07/15/Vue中computed分析/","link":"","permalink":"http://example.com/2022/07/15/Vue%E4%B8%ADcomputed%E5%88%86%E6%9E%90/","excerpt":"","text":"Vue中computed分析在Vue中computed是计算属性，其会根据所依赖的数据动态显示新的计算结果，虽然使用&#123;&#123;&#125;&#125;模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的，在模板中放入太多的逻辑会让模板过重且难以维护，所以对于任何复杂逻辑，都应当使用计算属性。计算属性是基于数据的响应式依赖进行缓存的，只在相关响应式依赖发生改变时它们才会重新求值，也就是说只要计算属性依赖的数据还没有发生改变，多次访问计算属性会立即返回之前的计算结果，而不必再次执行函数，当然如果不希望使用缓存可以使用方法属性并返回值即可，computed计算属性非常适用于一个数据受多个数据影响以及需要对数据进行预处理的条件下使用。 描述computed计算属性可以定义两种方式的参数，&#123; [key: string]: Function | &#123; get: Function, set: Function &#125; &#125;，计算属性直接定义在Vue实例中，所有getter和setter的this上下文自动地绑定为Vue实例，此外如果为一个计算属性使用了箭头函数，则this不会指向这个组件的实例，不过仍然可以将其实例作为函数的第一个参数来访问，计算属性的结果会被缓存，除非依赖的响应式property变化才会重新计算，注意如果某个依赖例如非响应式property在该实例范畴之外，则计算属性是不会被更新的。事实上computed会拥有自己的watcher，其内部有个属性dirty开关来决定computed的值是需要重新计算还是直接复用之前的值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; a: 1, b: 2 &#125;, template:` &lt;div&gt; &lt;div&gt;&#123;&#123;multiplication&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;multiplication&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;multiplication&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;multiplicationArrow&#125;&#125;&lt;/div&gt; &lt;button @click=&quot;updateSetting&quot;&gt;updateSetting&lt;/button&gt; &lt;/div&gt; `, computed:&#123; multiplication: function()&#123; console.log(&quot;a * b&quot;); // 初始只打印一次 返回值被缓存 return this.a * this.b; &#125;, multiplicationArrow: vm =&gt; vm.a * vm.b * 3, // 箭头函数可以通过传入的参数获取当前实例 setting: &#123; get: function()&#123; console.log(&quot;a * b * 6&quot;); return this.a * this.b * 6; &#125;, set: function(v)&#123; console.log(`$&#123;v&#125; -&gt; a`); this.a = v; &#125; &#125; &#125;, methods:&#123; updateSetting: function()&#123; // 点击按钮后 console.log(this.setting); // 12 this.setting = 3; // 3 -&gt; a console.log(this.setting); // 36 &#125; &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 分析首先在Vue中完成双向绑定是通过Object.defineProperty()实现的，Vue的双向数据绑定，简单点来说分为以下三个部分： Observer: 这里的主要工作是递归地监听对象上的所有属性，在属性值改变的时候，触发相应的Watcher。 Watcher: 观察者，当监听的数据值修改时，执行响应的回调函数，在Vue里面的更新模板内容。 Dep: 链接Observer和Watcher的桥梁，每一个Observer对应一个Dep，它内部维护一个数组，保存与该Observer相关的Watcher。 Vue源码的实现比较复杂，会处理各种兼容问题与异常以及各种条件分支，文章分析比较核心的代码部分，精简过后的版本，重要部分做出注释，commit id为0664cb0。首先在dev/src/core/instance/state.js中定义了初始化computed以及initComputed函数的实现，现在暂不考虑SSR服务端渲染的computed实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// dev/src/core/instance/state.js line 47export function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options // 获取组件定义的选项 if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) if (opts.data) &#123; initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) // 定义computed属性则进行初始化 if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125;// dev/src/core/instance/state.js line 169function initComputed (vm: Component, computed: Object) &#123; // $flow-disable-line const watchers = vm._computedWatchers = Object.create(null) // 创建一个没有原型链指向的对象 // computed properties are just getters during SSR const isSSR = isServerRendering() for (const key in computed) &#123; const userDef = computed[key] // 获取计算属性的key值定义 const getter = typeof userDef === &#x27;function&#x27; ? userDef : userDef.get // 由于计算属性接受两种类型的参数 此处判断用以获取getter if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; getter == null) &#123; warn( `Getter is missing for computed property &quot;$&#123;key&#125;&quot;.`, vm ) &#125; if (!isSSR) &#123; // create internal watcher for the computed property. // 生成computed watcher(vm, getter, noop, &#123; lazy: true &#125;) watchers[key] = new Watcher( // 计算属性创建观察者watcher和消息订阅器dep vm, getter || noop, noop, computedWatcherOptions ) &#125; // component-defined computed properties are already defined on the // component prototype. We only need to define computed properties defined // at instantiation here. if (!(key in vm)) &#123; // 检查重名属性 defineComputed(vm, key, userDef) // 定义属性 &#125; else if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; if (key in vm.$data) &#123; warn(`The computed property &quot;$&#123;key&#125;&quot; is already defined in data.`, vm) &#125; else if (vm.$options.props &amp;&amp; key in vm.$options.props) &#123; warn(`The computed property &quot;$&#123;key&#125;&quot; is already defined as a prop.`, vm) &#125; &#125; &#125;&#125; defineComputed传入了三个参数，vm实例、计算属性的key以及userDef计算属性的定义，属性描述符sharedPropertyDefinition在初始化定义之后经过userDef和shouldCache等多重判断后被重写，进而通过Object.defineProperty(target, key, sharedPropertyDefinition)进行属性的定义。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// dev/src/core/instance/state.js line 31const sharedPropertyDefinition = &#123; enumerable: true, configurable: true, get: noop, set: noop&#125;// dev/src/core/instance/state.js line 210export function defineComputed ( target: any, key: string, userDef: Object | Function) &#123; const shouldCache = !isServerRendering() if (typeof userDef === &#x27;function&#x27;) &#123; sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef) sharedPropertyDefinition.set = noop &#125; else &#123; sharedPropertyDefinition.get = userDef.get ? shouldCache &amp;&amp; userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop sharedPropertyDefinition.set = userDef.set || noop &#125; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; sharedPropertyDefinition.set === noop) &#123; sharedPropertyDefinition.set = function () &#123; warn( `Computed property &quot;$&#123;key&#125;&quot; was assigned to but it has no setter.`, this ) &#125; &#125; Object.defineProperty(target, key, sharedPropertyDefinition)&#125;/** 经过重写之后的属性描述符在某条件分支大致呈现如下 sharedPropertyDefinition = &#123; enumerable: true, configurable: true, get: function computedGetter () &#123; const watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key] if (watcher) &#123; if (watcher.dirty) &#123; watcher.evaluate() &#125; if (Dep.target) &#123; watcher.depend() &#125; return watcher.value &#125; &#125;, set: userDef.set || noop &#125; 当计算属性被调用时便会执行 get 访问函数，从而关联上观察者对象 watcher 然后执行 wather.depend() 收集依赖和 watcher.evaluate() 计算求值。*/ 每日一题1https://github.com/WindrunnerMax/EveryDay 参考123456https://cn.vuejs.org/v2/api/#computedhttps://juejin.im/post/6844903678533451783https://juejin.im/post/6844903873925087239https://cn.vuejs.org/v2/guide/computed.htmlhttps://zheyaoa.github.io/2019/09/07/computed/https://www.cnblogs.com/tugenhua0707/p/11760466.html","categories":[],"tags":[]},{"title":"理解","slug":"Vue中$refs的理解","date":"2022-07-15T07:36:39.357Z","updated":"2022-07-15T07:37:56.000Z","comments":true,"path":"2022/07/15/Vue中$refs的理解/","link":"","permalink":"http://example.com/2022/07/15/Vue%E4%B8%AD$refs%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"Vue中$refs的理解$refs是一个对象，持有注册过ref attribute的所有DOM元素和组件实例。 描述ref被用来给元素或子组件注册引用信息，引用信息将会注册在父组件的$refs对象上，如果在普通的DOM元素上使用，引用指向的就是DOM元素，如果用在子组件上，引用就指向组件实例，另外当v-for用于元素或组件的时候，引用信息将是包含DOM节点或组件实例的数组。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div ref=&quot;node&quot;&gt;Node&lt;/div&gt; &lt;layout-div ref=&quot;layout&quot;&gt;&lt;/layout-div&gt; &lt;div v-for=&quot;i in 3&quot; :key=&quot;i&quot; ref=&quot;nodearr&quot;&gt;&#123;&#123;i&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&quot;layout-div&quot;, &#123; data: function()&#123; return &#123; count: 0 &#125; &#125;, template: `&lt;div&gt; &lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt; &lt;/div&gt;` &#125;) var vm = new Vue(&#123; el: &#x27;#app&#x27;, mounted: function()&#123; console.log(this.$refs.node); // &lt;div&gt;Node&lt;/div&gt; // DOM元素 console.log(this.$refs.layout); // VueComponent &#123;_uid: 1, ...&#125; // 组件实例 console.log(this.$refs.nodearr); // (3) [div, div, div] // DOM元素数组 &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 因为ref本身是作为渲染结果被创建的，在初始渲染的时候是不能访问的，因为其还不存在，而且$refs也不是响应式的，因此不应该试图用它在模板中做数据绑定，在初始化访问ref时，应该在其生命周期的mounted方法中调用，在数据更新之后，应该在$nextTick方法中传递回调操作来获取元素或实例，此外一般不推荐直接操作DOM元素，尽量使用数据绑定让MVVM的ViewModel去操作DOM。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: function()&#123; return &#123; msg: 0 &#125; &#125;, template: `&lt;div&gt; &lt;div ref=&quot;node&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;button @click=&quot;updateMsg&quot;&gt;button&lt;/button&gt; &lt;/div&gt;`, beforeMount: function()&#123; console.log(this.$refs.node); // undefined &#125;, mounted: function()&#123; console.log(this.$refs.node); // &lt;div&gt;0&lt;/div&gt; &#125;, methods: &#123; updateMsg: function()&#123; this.msg = 1; console.log(this.$refs.node.innerHTML); // 0 this.$nextTick(() =&gt; &#123; console.log(this.$refs.node.innerHTML); // 1 &#125;) &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 每日一题1https://github.com/WindrunnerMax/EveryDay 参考123https://cn.vuejs.org/v2/api/#refhttps://zhuanlan.zhihu.com/p/50638655https://juejin.im/post/5da58c54e51d4524e207fb92","categories":[],"tags":[]},{"title":"￥nesttick","slug":"Vue中$nextTick的理解","date":"2022-07-15T07:36:39.313Z","updated":"2022-07-15T07:38:29.000Z","comments":true,"path":"2022/07/15/Vue中$nextTick的理解/","link":"","permalink":"http://example.com/2022/07/15/Vue%E4%B8%AD$nextTick%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"Vue中$nextTick的理解Vue中$nextTick方法将回调延迟到下次DOM更新循环之后执行，也就是在下次DOM更新循环结束之后执行延迟回调，在修改数据之后立即使用这个方法，能够获取更新后的DOM。简单来说就是当数据更新时，在DOM中渲染完成后，执行回调函数。 描述通过一个简单的例子来演示$nextTick方法的作用，首先需要知道Vue在更新DOM时是异步执行的，也就是说在更新数据时其不会阻塞代码的执行，直到执行栈中代码执行结束之后，才开始执行异步任务队列的代码，所以在数据更新时，组件不会立即渲染，此时在获取到DOM结构后取得的值依然是旧的值，而在$nextTick方法中设定的回调函数会在组件渲染完成之后执行，取得DOM结构后取得的值便是新的值。 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;Vue&#x27; &#125;, template:` &lt;div&gt; &lt;div ref=&quot;msgElement&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;button @click=&quot;updateMsg&quot;&gt;updateMsg&lt;/button&gt; &lt;/div&gt; `, methods:&#123; updateMsg: function()&#123; this.msg = &quot;Update&quot;; console.log(&quot;DOM未更新：&quot;, this.$refs.msgElement.innerHTML) this.$nextTick(() =&gt; &#123; console.log(&quot;DOM已更新：&quot;, this.$refs.msgElement.innerHTML) &#125;) &#125; &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 异步机制官方文档中说明，Vue在更新DOM时是异步执行的，只要侦听到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更，如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作是非常重要的。然后，在下一个的事件循环tick中，Vue刷新队列并执行实际工作。Vue在内部对异步队列尝试使用原生的Promise.then、MutationObserver和setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0)代替。Js是单线程的，其引入了同步阻塞与异步非阻塞的执行模式，在Js异步模式中维护了一个Event Loop，Event Loop是一个执行模型，在不同的地方有不同的实现，浏览器和NodeJS基于不同的技术实现了各自的Event Loop。浏览器的Event Loop是在HTML5的规范中明确定义，NodeJS的Event Loop是基于libuv实现的。在浏览器中的Event Loop由执行栈Execution Stack、后台线程Background Threads、宏队列Macrotask Queue、微队列Microtask Queue组成。 执行栈就是在主线程执行同步任务的数据结构，函数调用形成了一个由若干帧组成的栈。 后台线程就是浏览器实现对于setTimeout、setInterval、XMLHttpRequest等等的执行线程。 宏队列，一些异步任务的回调会依次进入宏队列，等待后续被调用，包括setTimeout、setInterval、setImmediate(Node)、requestAnimationFrame、UI rendering、I/O等操作 微队列，另一些异步任务的回调会依次进入微队列，等待后续调用，包括Promise、process.nextTick(Node)、Object.observe、MutationObserver等操作 当Js执行时，进行如下流程 首先将执行栈中代码同步执行，将这些代码中异步任务加入后台线程中 执行栈中的同步代码执行完毕后，执行栈清空，并开始扫描微队列 取出微队列队首任务，放入执行栈中执行，此时微队列是进行了出队操作 当执行栈执行完成后，继续出队微队列任务并执行，直到微队列任务全部执行完毕 最后一个微队列任务出队并进入执行栈后微队列中任务为空，当执行栈任务完成后，开始扫面微队列为空，继续扫描宏队列任务，宏队列出队，放入执行栈中执行，执行完毕后继续扫描微队列为空则扫描宏队列，出队执行 不断往复… 实例12345678910111213141516171819202122232425262728293031323334353637383940// Step 1console.log(1);// Step 2setTimeout(() =&gt; &#123; console.log(2); Promise.resolve().then(() =&gt; &#123; console.log(3); &#125;);&#125;, 0);// Step 3new Promise((resolve, reject) =&gt; &#123; console.log(4); resolve();&#125;).then(() =&gt; &#123; console.log(5);&#125;)// Step 4setTimeout(() =&gt; &#123; console.log(6);&#125;, 0);// Step 5console.log(7);// Step N// ...// Result/* 1 4 7 5 2 3 6*/ Step 11234// 执行栈 console// 微队列 []// 宏队列 []console.log(1); // 1 Step 2123456789// 执行栈 setTimeout// 微队列 []// 宏队列 [setTimeout1]setTimeout(() =&gt; &#123; console.log(2); Promise.resolve().then(() =&gt; &#123; console.log(3); &#125;);&#125;, 0); Step 3123456789// 执行栈 Promise// 微队列 [then1]// 宏队列 [setTimeout1]new Promise((resolve, reject) =&gt; &#123; console.log(4); // 4 // Promise是个函数对象，此处是同步执行的 // 执行栈 Promise console resolve();&#125;).then(() =&gt; &#123; console.log(5);&#125;) Step 4123456// 执行栈 setTimeout// 微队列 [then1]// 宏队列 [setTimeout1 setTimeout2]setTimeout(() =&gt; &#123; console.log(6);&#125;, 0); Step 51234// 执行栈 console// 微队列 [then1]// 宏队列 [setTimeout1 setTimeout2]console.log(7); // 7 Step 61234// 执行栈 then1// 微队列 []// 宏队列 [setTimeout1 setTimeout2]console.log(5); // 5 Step 71234567// 执行栈 setTimeout1// 微队列 [then2]// 宏队列 [setTimeout2]console.log(2); // 2Promise.resolve().then(() =&gt; &#123; console.log(3);&#125;); Step 81234// 执行栈 then2// 微队列 []// 宏队列 [setTimeout2]console.log(3); // 3 Step 91234// 执行栈 setTimeout2// 微队列 []// 宏队列 []console.log(6); // 6 分析在了解异步任务的执行队列后，回到中$nextTick方法，当用户数据更新时，Vue将会维护一个缓冲队列，对于所有的更新数据将要进行的组件渲染与DOM操作进行一定的策略处理后加入缓冲队列，然后便会在$nextTick方法的执行队列中加入一个flushSchedulerQueue方法(这个方法将会触发在缓冲队列的所有回调的执行)，然后将$nextTick方法的回调加入$nextTick方法中维护的执行队列，在异步挂载的执行队列触发时就会首先会首先执行flushSchedulerQueue方法来处理DOM渲染的任务，然后再去执行$nextTick方法构建的任务，这样就可以实现在$nextTick方法中取得已渲染完成的DOM结构。在测试的过程中发现了一个很有意思的现象，在上述例子中的加入两个按钮，在点击updateMsg按钮的结果是3 2 1，点击updateMsgTest按钮的运行结果是2 3 1。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;Vue&#x27; &#125;, template:` &lt;div&gt; &lt;div ref=&quot;msgElement&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;button @click=&quot;updateMsg&quot;&gt;updateMsg&lt;/button&gt; &lt;button @click=&quot;updateMsgTest&quot;&gt;updateMsgTest&lt;/button&gt; &lt;/div&gt; `, methods:&#123; updateMsg: function()&#123; this.msg = &quot;Update&quot;; setTimeout(() =&gt; console.log(1)) Promise.resolve().then(() =&gt; console.log(2)) this.$nextTick(() =&gt; &#123; console.log(3) &#125;) &#125;, updateMsgTest: function()&#123; setTimeout(() =&gt; console.log(1)) Promise.resolve().then(() =&gt; console.log(2)) this.$nextTick(() =&gt; &#123; console.log(3) &#125;) &#125; &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 这里假设运行环境中Promise对象是完全支持的，那么使用setTimeout是宏队列在最后执行这个是没有异议的，但是使用$nextTick方法以及自行定义的Promise实例是有执行顺序的问题的，虽然都是微队列任务，但是在Vue中具体实现的原因导致了执行顺序可能会有所不同，首先直接看一下$nextTick方法的源码，关键地方添加了注释，请注意这是Vue2.4.2版本的源码，在后期$nextTick方法可能有所变更。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * Defer a task to execute it asynchronously. */var nextTick = (function () &#123; // 闭包 内部变量 var callbacks = []; // 执行队列 var pending = false; // 标识，用以判断在某个事件循环中是否为第一次加入，第一次加入的时候才触发异步执行的队列挂载 var timerFunc; // 以何种方法执行挂载异步执行队列，这里假设Promise是完全支持的 function nextTickHandler () &#123; // 异步挂载的执行任务，触发时就已经正式准备开始执行异步任务了 pending = false; // 标识置false var copies = callbacks.slice(0); // 创建副本 callbacks.length = 0; // 执行队列置空 for (var i = 0; i &lt; copies.length; i++) &#123; copies[i](); // 执行 &#125; &#125; // the nextTick behavior leverages the microtask queue, which can be accessed // via either native Promise.then or MutationObserver. // MutationObserver has wider support, however it is seriously bugged in // UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It // completely stops working after triggering a few times... so, if native // Promise is available, we will use it: /* istanbul ignore if */ if (typeof Promise !== &#x27;undefined&#x27; &amp;&amp; isNative(Promise)) &#123; var p = Promise.resolve(); var logError = function (err) &#123; console.error(err); &#125;; timerFunc = function () &#123; p.then(nextTickHandler).catch(logError); // 挂载异步任务队列 // in problematic UIWebViews, Promise.then doesn&#x27;t completely break, but // it can get stuck in a weird state where callbacks are pushed into the // microtask queue but the queue isn&#x27;t being flushed, until the browser // needs to do some other work, e.g. handle a timer. Therefore we can // &quot;force&quot; the microtask queue to be flushed by adding an empty timer. if (isIOS) &#123; setTimeout(noop); &#125; &#125;; &#125; else if (typeof MutationObserver !== &#x27;undefined&#x27; &amp;&amp; ( isNative(MutationObserver) || // PhantomJS and iOS 7.x MutationObserver.toString() === &#x27;[object MutationObserverConstructor]&#x27; )) &#123; // use MutationObserver where native Promise is not available, // e.g. PhantomJS IE11, iOS7, Android 4.4 var counter = 1; var observer = new MutationObserver(nextTickHandler); var textNode = document.createTextNode(String(counter)); observer.observe(textNode, &#123; characterData: true &#125;); timerFunc = function () &#123; counter = (counter + 1) % 2; textNode.data = String(counter); &#125;; &#125; else &#123; // fallback to setTimeout /* istanbul ignore next */ timerFunc = function () &#123; setTimeout(nextTickHandler, 0); &#125;; &#125; return function queueNextTick (cb, ctx) &#123; // nextTick方法真正导出的方法 var _resolve; callbacks.push(function () &#123; // 添加到执行队列中 并加入异常处理 if (cb) &#123; try &#123; cb.call(ctx); &#125; catch (e) &#123; handleError(e, ctx, &#x27;nextTick&#x27;); &#125; &#125; else if (_resolve) &#123; _resolve(ctx); &#125; &#125;); //判断在当前事件循环中是否为第一次加入，若是第一次加入则置标识为true并执行timerFunc函数用以挂载执行队列到Promise // 这个标识在执行队列中的任务将要执行时便置为false并创建执行队列的副本去运行执行队列中的任务，参见nextTickHandler函数的实现 // 在当前事件循环中置标识true并挂载，然后再次调用nextTick方法时只是将任务加入到执行队列中，直到挂载的异步任务触发，便置标识为false然后执行任务，再次调用nextTick方法时就是同样的执行方式然后不断如此往复 if (!pending) &#123; pending = true; timerFunc(); &#125; if (!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123; return new Promise(function (resolve, reject) &#123; _resolve = resolve; &#125;) &#125; &#125;&#125;)(); 回到刚才提出的问题上，在更新DOM操作时会先触发$nextTick方法的回调，解决这个问题的关键在于谁先将异步任务挂载到Promise对象上。首先对有数据更新的updateMsg按钮触发的方法进行debug，断点设置在Vue.js的715行，版本为2.4.2，在查看调用栈以及传入的参数时可以观察到第一次执行$nextTick方法的其实是由于数据更新而调用的nextTick(flushSchedulerQueue);语句，也就是说在执行this.msg = &quot;Update&quot;;的时候就已经触发了第一次的$nextTick方法，此时在$nextTick方法中的任务队列会首先将flushSchedulerQueue方法加入队列并挂载$nextTick方法的执行队列到Promise对象上，然后才是自行自定义的Promise.resolve().then(() =&gt; console.log(2))语句的挂载，当执行微任务队列中的任务时，首先会执行第一个挂载到Promise的任务，此时这个任务是运行执行队列，这个队列中有两个方法，首先会运行flushSchedulerQueue方法去触发组件的DOM渲染操作，然后再执行console.log(3)，然后执行第二个微队列的任务也就是() =&gt; console.log(2)，此时微任务队列清空，然后再去宏任务队列执行console.log(1)。接下来对于没有数据更新的updateMsgTest按钮触发的方法进行debug，断点设置在同样的位置，此时没有数据更新，那么第一次触发$nextTick方法的是自行定义的回调函数，那么此时$nextTick方法的执行队列才会被挂载到Promise对象上，很显然在此之前自行定义的输出2的Promise回调已经被挂载，那么对于这个按钮绑定的方法的执行流程便是首先执行console.log(2)，然后执行$nextTick方法闭包的执行队列，此时执行队列中只有一个回调函数console.log(3)，此时微任务队列清空，然后再去宏任务队列执行console.log(1)。简单来说就是谁先挂载Promise对象的问题，在调用$nextTick方法时就会将其闭包内部维护的执行队列挂载到Promise对象，在数据更新时Vue内部首先就会执行$nextTick方法，之后便将执行队列挂载到了Promise对象上，其实在明白Js的Event Loop模型后，将数据更新也看做一个$nextTick方法的调用，并且明白$nextTick方法会一次性执行所有推入的回调，就可以明白其执行顺序的问题了，下面是一个关于$nextTick方法的最小化的DEMO。 12345678910111213141516171819202122232425262728293031323334var nextTick = (function()&#123; var pending = false; const callback = []; var p = Promise.resolve(); var handler = function()&#123; pending = true; callback.forEach(fn =&gt; fn()); &#125; var timerFunc = function()&#123; p.then(handler); &#125; return function queueNextTick(fn)&#123; callback.push(() =&gt; fn()); if(!pending)&#123; pending = true; timerFunc(); &#125; &#125;&#125;)();(function()&#123; nextTick(() =&gt; console.log(&quot;触发DOM渲染队列的方法&quot;)); // 注释 / 取消注释 来查看效果 setTimeout(() =&gt; console.log(1)) Promise.resolve().then(() =&gt; console.log(2)) nextTick(() =&gt; &#123; console.log(3) &#125;)&#125;)(); 每日一题1https://github.com/WindrunnerMax/EveryDay 参考123456https://www.jianshu.com/p/e7ce7613f630https://cn.vuejs.org/v2/api/#vm-nextTickhttps://segmentfault.com/q/1010000021240464https://juejin.im/post/5d391ad8f265da1b8d166175https://juejin.im/post/5ab94ee251882577b45f05c7https://juejin.im/post/5a45fdeb6fb9a044ff31c9a8","categories":[],"tags":[]},{"title":"","slug":"Vue为何采用异步渲染","date":"2022-07-15T07:36:39.269Z","updated":"2022-02-23T08:57:59.000Z","comments":true,"path":"2022/07/15/Vue为何采用异步渲染/","link":"","permalink":"http://example.com/2022/07/15/Vue%E4%B8%BA%E4%BD%95%E9%87%87%E7%94%A8%E5%BC%82%E6%AD%A5%E6%B8%B2%E6%9F%93/","excerpt":"","text":"Vue为何采用异步渲染Vue在更新DOM时是异步执行的，只要侦听到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更，如果同一个watcher被多次触发，只会被推入到队列中一次，这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作是非常重要的，然后，在下一个的事件循环tick中，Vue刷新队列并执行实际(已去重的)工作，Vue在内部对异步队列尝试使用原生的Promise.then、MutationObserver和setImmediate，如果执行环境不支持，则会采用setTimeout(fn, 0)代替。 描述对于Vue为何采用异步渲染，简单来说就是为了提升性能，因为不采用异步更新，在每次更新数据都会对当前组件进行重新渲染，为了性能考虑，Vue会在本轮数据更新后，再去异步更新视图，举个例子，让我们在一个方法内重复更新一个值。 123this.msg = 1;this.msg = 2;this.msg = 3; 事实上，我们真正想要的其实只是最后一次更新而已，也就是说前三次DOM更新都是可以省略的，我们只需要等所有状态都修改好了之后再进行渲染就可以减少一些性能损耗。对于渲染方面的问题是很明确的，最终只渲染一次肯定比修改之后即渲染所耗费的性能少，在这里我们还需要考虑一下异步更新队列的相关问题，假设我们现在是进行了相关处理使得每次更新数据只进行一次真实DOM渲染，来让我们考虑异步更新队列的性能优化。假设这里是同步更新队列，this.msg=1，大致会发生这些事: msg值更新 -&gt; 触发setter -&gt; 触发Watcher的update -&gt; 重新调用 render -&gt; 生成新的vdom -&gt; dom-diff -&gt; dom更新，这里的dom更新并不是渲染(即布局、绘制、合成等一系列步骤)，而是更新内存中的DOM树结构，之后再运行this.msg=2，再重复上述步骤，之后的第3次更新同样会触发相同的流程，等开始渲染的时候，最新的DOM树中确实只会存在更新完成3，从这里来看，前2次对msg的操作以及Vue内部对它的处理都是无用的操作，可以进行优化处理。如果是异步更新队列，会是下面的情况，运行this.msg=1，并不是立即进行上面的流程，而是将对msg有依赖的Watcher都保存在队列中，该队列可能这样[Watcher1, Watcher2...]，当运行this.msg=2后，同样是将对msg有依赖的Watcher保存到队列中，Vue内部会做去重判断，这次操作后，可以认为队列数据没有发生变化，第3次更新也是上面的过程，当然，你不可能只对msg有操作，你可能对该组件中的另一个属性也有操作，比如this.otherMsg=othermessage，同样会把对otherMsg有依赖的Watcher添加到异步更新队列中，因为有重复判断操作，这个Watcher也只会在队列中存在一次，本次异步任务执行结束后，会进入下一个任务执行流程，其实就是遍历异步更新队列中的每一个Watcher，触发其update，然后进行重新调用render -&gt; new vdom -&gt; dom-diff -&gt; dom更新等流程，但是这种方式和同步更新队列相比，不管操作多少次msg， Vue在内部只会进行一次重新调用真实更新流程，所以，对于异步更新队列不是节省了渲染成本，而是节省了Vue内部计算及DOM树操作的成本，不管采用哪种方式，渲染确实只有一次。此外，组件内部实际使用VirtualDOM进行渲染，也就是说，组件内部其实是不关心哪个状态发生了变化，它只需要计算一次就可以得知哪些节点需要更新，也就是说，如果更改了N个状态，其实只需要发送一个信号就可以将DOM更新到最新，如果我们更新多个值。 123this.msg = 1;this.age = 2;this.name = 3; 此处我们分三次修改了三种状态，但其实Vue只会渲染一次，因为VIrtualDOM只需要一次就可以将整个组件的DOM更新到最新，它根本不会关心这个更新的信号到底是从哪个具体的状态发出来的。而为了达到这个目的，我们需要将渲染操作推迟到所有的状态都修改完成，为了做到这一点只需要将渲染操作推迟到本轮事件循环的最后或者下一轮事件循环，也就是说，只需要在本轮事件循环的最后，等前面更新状态的语句都执行完之后，执行一次渲染操作，它就可以无视前面各种更新状态的语法，无论前面写了多少条更新状态的语句，只在最后渲染一次就可以了。将渲染推迟到本轮事件循环的最后执行渲染的时机会比推迟到下一轮快很多，所以Vue优先将渲染操作推迟到本轮事件循环的最后，如果执行环境不支持会降级到下一轮，Vue的变化侦测机制(setter)决定了它必然会在每次状态发生变化时都会发出渲染的信号，但Vue会在收到信号之后检查队列中是否已经存在这个任务，保证队列中不会有重复，如果队列中不存在则将渲染操作添加到队列中，之后通过异步的方式延迟执行队列中的所有渲染的操作并清空队列，当同一轮事件循环中反复修改状态时，并不会反复向队列中添加相同的渲染操作，所以我们在使用Vue时，修改状态后更新DOM都是异步的。当数据变化后会调用notify方法，将watcher遍历，调用update方法通知watcher进行更新，这时候watcher并不会立即去执行，在update中会调用queueWatcher方法将watcher放到了一个队列里，在queueWatcher会根据watcher的进行去重，若多个属性依赖一个watcher，则如果队列中没有该watcher就会将该watcher添加到队列中，然后便会在$nextTick方法的执行队列中加入一个flushSchedulerQueue方法(这个方法将会触发在缓冲队列的所有回调的执行)，然后将$nextTick方法的回调加入$nextTick方法中维护的执行队列，flushSchedulerQueue中开始会触发一个before的方法，其实就是beforeUpdate，然后watcher.run()才开始真正执行watcher，执行完页面就渲染完成，更新完成后会调用updated钩子。 $nextTick在上文中谈到了对于Vue为何采用异步渲染，假如此时我们有一个需求，需要在页面渲染完成后取得页面的DOM元素，而由于渲染是异步的，我们不能直接在定义的方法中同步取得这个值的，于是就有了vm.$nextTick方法，Vue中$nextTick方法将回调延迟到下次DOM更新循环之后执行，也就是在下次DOM更新循环结束之后执行延迟回调，在修改数据之后立即使用这个方法，能够获取更新后的DOM。简单来说就是当数据更新时，在DOM中渲染完成后，执行回调函数。通过一个简单的例子来演示$nextTick方法的作用，首先需要知道Vue在更新DOM时是异步执行的，也就是说在更新数据时其不会阻塞代码的执行，直到执行栈中代码执行结束之后，才开始执行异步任务队列的代码，所以在数据更新时，组件不会立即渲染，此时在获取到DOM结构后取得的值依然是旧的值，而在$nextTick方法中设定的回调函数会在组件渲染完成之后执行，取得DOM结构后取得的值便是新的值。 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;Vue&#x27; &#125;, template:` &lt;div&gt; &lt;div ref=&quot;msgElement&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;button @click=&quot;updateMsg&quot;&gt;updateMsg&lt;/button&gt; &lt;/div&gt; `, methods:&#123; updateMsg: function()&#123; this.msg = &quot;Update&quot;; console.log(&quot;DOM未更新：&quot;, this.$refs.msgElement.innerHTML) this.$nextTick(() =&gt; &#123; console.log(&quot;DOM已更新：&quot;, this.$refs.msgElement.innerHTML) &#125;) &#125; &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 异步机制官方文档中说明，Vue在更新DOM时是异步执行的，只要侦听到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更，如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作是非常重要的。然后，在下一个的事件循环tick中，Vue刷新队列并执行实际工作。Vue在内部对异步队列尝试使用原生的Promise.then、MutationObserver和setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0)代替。Js是单线程的，其引入了同步阻塞与异步非阻塞的执行模式，在Js异步模式中维护了一个Event Loop，Event Loop是一个执行模型，在不同的地方有不同的实现，浏览器和NodeJS基于不同的技术实现了各自的Event Loop。浏览器的Event Loop是在HTML5的规范中明确定义，NodeJS的Event Loop是基于libuv实现的。在浏览器中的Event Loop由执行栈Execution Stack、后台线程Background Threads、宏队列Macrotask Queue、微队列Microtask Queue组成。 执行栈就是在主线程执行同步任务的数据结构，函数调用形成了一个由若干帧组成的栈。 后台线程就是浏览器实现对于setTimeout、setInterval、XMLHttpRequest等等的执行线程。 宏队列，一些异步任务的回调会依次进入宏队列，等待后续被调用，包括setTimeout、setInterval、setImmediate(Node)、requestAnimationFrame、UI rendering、I/O等操作。 微队列，另一些异步任务的回调会依次进入微队列，等待后续调用，包括Promise、process.nextTick(Node)、Object.observe、MutationObserver等操作。 当Js执行时，进行如下流程: 首先将执行栈中代码同步执行，将这些代码中异步任务加入后台线程中。 执行栈中的同步代码执行完毕后，执行栈清空，并开始扫描微队列。 取出微队列队首任务，放入执行栈中执行，此时微队列是进行了出队操作。 当执行栈执行完成后，继续出队微队列任务并执行，直到微队列任务全部执行完毕。 最后一个微队列任务出队并进入执行栈后微队列中任务为空，当执行栈任务完成后，开始扫面微队列为空，继续扫描宏队列任务，宏队列出队，放入执行栈中执行，执行完毕后继续扫描微队列为空则扫描宏队列，出队执行。 不断往复...。 实例12345678910111213141516171819202122232425262728293031323334353637383940// Step 1console.log(1);// Step 2setTimeout(() =&gt; &#123; console.log(2); Promise.resolve().then(() =&gt; &#123; console.log(3); &#125;);&#125;, 0);// Step 3new Promise((resolve, reject) =&gt; &#123; console.log(4); resolve();&#125;).then(() =&gt; &#123; console.log(5);&#125;)// Step 4setTimeout(() =&gt; &#123; console.log(6);&#125;, 0);// Step 5console.log(7);// Step N// ...// Result/* 1 4 7 5 2 3 6*/ Step 11234// 执行栈 console// 微队列 []// 宏队列 []console.log(1); // 1 Step 2123456789// 执行栈 setTimeout// 微队列 []// 宏队列 [setTimeout1]setTimeout(() =&gt; &#123; console.log(2); Promise.resolve().then(() =&gt; &#123; console.log(3); &#125;);&#125;, 0); Step 3123456789// 执行栈 Promise// 微队列 [then1]// 宏队列 [setTimeout1]new Promise((resolve, reject) =&gt; &#123; console.log(4); // 4 // Promise是个函数对象，此处是同步执行的 // 执行栈 Promise console resolve();&#125;).then(() =&gt; &#123; console.log(5);&#125;) Step 4123456// 执行栈 setTimeout// 微队列 [then1]// 宏队列 [setTimeout1 setTimeout2]setTimeout(() =&gt; &#123; console.log(6);&#125;, 0); Step 51234// 执行栈 console// 微队列 [then1]// 宏队列 [setTimeout1 setTimeout2]console.log(7); // 7 Step 61234// 执行栈 then1// 微队列 []// 宏队列 [setTimeout1 setTimeout2]console.log(5); // 5 Step 71234567// 执行栈 setTimeout1// 微队列 [then2]// 宏队列 [setTimeout2]console.log(2); // 2Promise.resolve().then(() =&gt; &#123; console.log(3);&#125;); Step 81234// 执行栈 then2// 微队列 []// 宏队列 [setTimeout2]console.log(3); // 3 Step 91234// 执行栈 setTimeout2// 微队列 []// 宏队列 []console.log(6); // 6 分析在了解异步任务的执行队列后，回到中$nextTick方法，当用户数据更新时，Vue将会维护一个缓冲队列，对于所有的更新数据将要进行的组件渲染与DOM操作进行一定的策略处理后加入缓冲队列，然后便会在$nextTick方法的执行队列中加入一个flushSchedulerQueue方法(这个方法将会触发在缓冲队列的所有回调的执行)，然后将$nextTick方法的回调加入$nextTick方法中维护的执行队列，在异步挂载的执行队列触发时就会首先会首先执行flushSchedulerQueue方法来处理DOM渲染的任务，然后再去执行$nextTick方法构建的任务，这样就可以实现在$nextTick方法中取得已渲染完成的DOM结构。在测试的过程中发现了一个很有意思的现象，在上述例子中的加入两个按钮，在点击updateMsg按钮的结果是3 2 1，点击updateMsgTest按钮的运行结果是2 3 1。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;Vue&#x27; &#125;, template:` &lt;div&gt; &lt;div ref=&quot;msgElement&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;button @click=&quot;updateMsg&quot;&gt;updateMsg&lt;/button&gt; &lt;button @click=&quot;updateMsgTest&quot;&gt;updateMsgTest&lt;/button&gt; &lt;/div&gt; `, methods:&#123; updateMsg: function()&#123; this.msg = &quot;Update&quot;; setTimeout(() =&gt; console.log(1)) Promise.resolve().then(() =&gt; console.log(2)) this.$nextTick(() =&gt; &#123; console.log(3) &#125;) &#125;, updateMsgTest: function()&#123; setTimeout(() =&gt; console.log(1)) Promise.resolve().then(() =&gt; console.log(2)) this.$nextTick(() =&gt; &#123; console.log(3) &#125;) &#125; &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 这里假设运行环境中Promise对象是完全支持的，那么使用setTimeout是宏队列在最后执行这个是没有异议的，但是使用$nextTick方法以及自行定义的Promise实例是有执行顺序的问题的，虽然都是微队列任务，但是在Vue中具体实现的原因导致了执行顺序可能会有所不同，首先直接看一下$nextTick方法的源码，关键地方添加了注释，请注意这是Vue2.4.2版本的源码，在后期$nextTick方法可能有所变更。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * Defer a task to execute it asynchronously. */var nextTick = (function () &#123; // 闭包 内部变量 var callbacks = []; // 执行队列 var pending = false; // 标识，用以判断在某个事件循环中是否为第一次加入，第一次加入的时候才触发异步执行的队列挂载 var timerFunc; // 以何种方法执行挂载异步执行队列，这里假设Promise是完全支持的 function nextTickHandler () &#123; // 异步挂载的执行任务，触发时就已经正式准备开始执行异步任务了 pending = false; // 标识置false var copies = callbacks.slice(0); // 创建副本 callbacks.length = 0; // 执行队列置空 for (var i = 0; i &lt; copies.length; i++) &#123; copies[i](); // 执行 &#125; &#125; // the nextTick behavior leverages the microtask queue, which can be accessed // via either native Promise.then or MutationObserver. // MutationObserver has wider support, however it is seriously bugged in // UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It // completely stops working after triggering a few times... so, if native // Promise is available, we will use it: /* istanbul ignore if */ if (typeof Promise !== &#x27;undefined&#x27; &amp;&amp; isNative(Promise)) &#123; var p = Promise.resolve(); var logError = function (err) &#123; console.error(err); &#125;; timerFunc = function () &#123; p.then(nextTickHandler).catch(logError); // 挂载异步任务队列 // in problematic UIWebViews, Promise.then doesn&#x27;t completely break, but // it can get stuck in a weird state where callbacks are pushed into the // microtask queue but the queue isn&#x27;t being flushed, until the browser // needs to do some other work, e.g. handle a timer. Therefore we can // &quot;force&quot; the microtask queue to be flushed by adding an empty timer. if (isIOS) &#123; setTimeout(noop); &#125; &#125;; &#125; else if (typeof MutationObserver !== &#x27;undefined&#x27; &amp;&amp; ( isNative(MutationObserver) || // PhantomJS and iOS 7.x MutationObserver.toString() === &#x27;[object MutationObserverConstructor]&#x27; )) &#123; // use MutationObserver where native Promise is not available, // e.g. PhantomJS IE11, iOS7, Android 4.4 var counter = 1; var observer = new MutationObserver(nextTickHandler); var textNode = document.createTextNode(String(counter)); observer.observe(textNode, &#123; characterData: true &#125;); timerFunc = function () &#123; counter = (counter + 1) % 2; textNode.data = String(counter); &#125;; &#125; else &#123; // fallback to setTimeout /* istanbul ignore next */ timerFunc = function () &#123; setTimeout(nextTickHandler, 0); &#125;; &#125; return function queueNextTick (cb, ctx) &#123; // nextTick方法真正导出的方法 var _resolve; callbacks.push(function () &#123; // 添加到执行队列中 并加入异常处理 if (cb) &#123; try &#123; cb.call(ctx); &#125; catch (e) &#123; handleError(e, ctx, &#x27;nextTick&#x27;); &#125; &#125; else if (_resolve) &#123; _resolve(ctx); &#125; &#125;); //判断在当前事件循环中是否为第一次加入，若是第一次加入则置标识为true并执行timerFunc函数用以挂载执行队列到Promise // 这个标识在执行队列中的任务将要执行时便置为false并创建执行队列的副本去运行执行队列中的任务，参见nextTickHandler函数的实现 // 在当前事件循环中置标识true并挂载，然后再次调用nextTick方法时只是将任务加入到执行队列中，直到挂载的异步任务触发，便置标识为false然后执行任务，再次调用nextTick方法时就是同样的执行方式然后不断如此往复 if (!pending) &#123; pending = true; timerFunc(); &#125; if (!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123; return new Promise(function (resolve, reject) &#123; _resolve = resolve; &#125;) &#125; &#125;&#125;)(); 回到刚才提出的问题上，在更新DOM操作时会先触发$nextTick方法的回调，解决这个问题的关键在于谁先将异步任务挂载到Promise对象上。首先对有数据更新的updateMsg按钮触发的方法进行debug，断点设置在Vue.js的715行，版本为2.4.2，在查看调用栈以及传入的参数时可以观察到第一次执行$nextTick方法的其实是由于数据更新而调用的nextTick(flushSchedulerQueue);语句，也就是说在执行this.msg = &quot;Update&quot;;的时候就已经触发了第一次的$nextTick方法，此时在$nextTick方法中的任务队列会首先将flushSchedulerQueue方法加入队列并挂载$nextTick方法的执行队列到Promise对象上，然后才是自行自定义的Promise.resolve().then(() =&gt; console.log(2))语句的挂载，当执行微任务队列中的任务时，首先会执行第一个挂载到Promise的任务，此时这个任务是运行执行队列，这个队列中有两个方法，首先会运行flushSchedulerQueue方法去触发组件的DOM渲染操作，然后再执行console.log(3)，然后执行第二个微队列的任务也就是() =&gt; console.log(2)，此时微任务队列清空，然后再去宏任务队列执行console.log(1)。接下来对于没有数据更新的updateMsgTest按钮触发的方法进行debug，断点设置在同样的位置，此时没有数据更新，那么第一次触发$nextTick方法的是自行定义的回调函数，那么此时$nextTick方法的执行队列才会被挂载到Promise对象上，很显然在此之前自行定义的输出2的Promise回调已经被挂载，那么对于这个按钮绑定的方法的执行流程便是首先执行console.log(2)，然后执行$nextTick方法闭包的执行队列，此时执行队列中只有一个回调函数console.log(3)，此时微任务队列清空，然后再去宏任务队列执行console.log(1)。简单来说就是谁先挂载Promise对象的问题，在调用$nextTick方法时就会将其闭包内部维护的执行队列挂载到Promise对象，在数据更新时Vue内部首先就会执行$nextTick方法，之后便将执行队列挂载到了Promise对象上，其实在明白Js的Event Loop模型后，将数据更新也看做一个$nextTick方法的调用，并且明白$nextTick方法会一次性执行所有推入的回调，就可以明白其执行顺序的问题了，下面是一个关于$nextTick方法的最小化的DEMO。 12345678910111213141516171819202122232425262728293031323334var nextTick = (function()&#123; var pending = false; const callback = []; var p = Promise.resolve(); var handler = function()&#123; pending = true; callback.forEach(fn =&gt; fn()); &#125; var timerFunc = function()&#123; p.then(handler); &#125; return function queueNextTick(fn)&#123; callback.push(() =&gt; fn()); if(!pending)&#123; pending = true; timerFunc(); &#125; &#125;&#125;)();(function()&#123; nextTick(() =&gt; console.log(&quot;触发DOM渲染队列的方法&quot;)); // 注释 / 取消注释 来查看效果 setTimeout(() =&gt; console.log(1)) Promise.resolve().then(() =&gt; console.log(2)) nextTick(() =&gt; &#123; console.log(3) &#125;)&#125;)(); 每日一题1https://github.com/WindrunnerMax/EveryDay 参考123456https://zhuanlan.zhihu.com/p/29631893https://github.com/berwin/Blog/issues/22https://juejin.cn/post/6899822303022956552https://segmentfault.com/a/1190000015698196https://cn.vuejs.org/v2/guide/reactivity.htmlhttps://blog.csdn.net/weixin_46396187/article/details/107462329","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-07-15T07:12:21.715Z","updated":"2022-07-15T07:12:21.715Z","comments":true,"path":"2022/07/15/hello-world/","link":"","permalink":"http://example.com/2022/07/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}